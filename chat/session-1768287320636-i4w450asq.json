[ {
  "type" : "USER",
  "content" : "Spring 循环依赖"
}, {
  "type" : "ASSISTANT",
  "content" : "好的，我们来深入浅出地聊一聊 Spring 的循环依赖（Circular Dependency）。\n\n这是一个在 Spring 开发中非常经典且重要的问题，理解它有助于你更好地设计 Bean 的结构和理解 Spring 的底层原理。\n\n### 1. 什么是循环依赖？\n\n简单来说，循环依赖就是 **两个或多个 Bean 之间相互依赖，形成了一个闭环**。\n\n最常见的场景是两个 Bean 的相互依赖：\n\n*   Bean A 依赖 Bean B (`@Autowired B b;`)\n*   Bean B 依赖 Bean A (`@Autowired A a;`)\n\n```\n      +-----------+         +-----------+\n      |   Bean A  | ------> |   Bean B  |\n      |  (需要 B)  |         |  (需要 A)  |\n      +-----------+         +-----------+\n             ^                     |\n             |                     |\n             +---------------------+\n```\n\n如果处理不当，Spring 容器在创建 Bean A 的时候，发现需要 Bean B，于是去创建 Bean B；在创建 Bean B 的时候，又发现需要 Bean A，于是又回头去创建 Bean A…… 这样就陷入了死循环。\n\n### 2. Spring 如何解决循环依赖？\n\nSpring 并不是简单地打破这个循环，而是通过一个非常巧妙的 **三级缓存** 机制来解决 **Setter/Field 注入** 的循环依赖问题。\n\n首先，你需要知道，Spring 创建一个 Bean 的大致过程（简化版）：\n1.  **实例化 (Instantiation)**：通过构造函数或工厂方法创建一个 Bean 的原始对象（此时对象中的属性都还未填充）。\n2.  **属性填充 (Population)**：给 Bean 的属性赋值（比如处理 `@Autowired`）。\n3.  **初始化 (Initialization)**：调用 `@PostConstruct` 标注的方法、`init-method` 等。\n\nSpring 解决循环依赖的核心思想是：**先不等待 Bean 完全初始化好，而是先将“半成品”的 Bean 暴露出去，让其他 Bean 可以先引用到它。**\n\n这个“半成品”就存放在三级缓存中。\n\n#### Spring 的三级缓存\n\n这三级缓存都是 `Map` 结构，定义在 `org.springframework.beans.factory.support.DefaultSingletonBeanRegistry` 类中：\n\n1.  **singletonObjects (一级缓存)**：\n    *   **作用**：存放 **完全成熟** 的单例 Bean。\n    *   **别名**：`singletonObjects`。\n    *   **Bean 的状态**：已经实例化、属性填充、初始化完成。这是你最终从容器中 `getBean()` 得到的对象。\n\n2.  **earlySingletonObjects (二级缓存)**：\n    *   **作用**：存放 **早期暴露** 的单例 Bean。\n    *   **Bean 的状态**：已经实例化，但 **尚未填充属性和初始化**。\n    *   **目的**：为了解决循环依赖。当一个 Bean 需要被注入到另一个 Bean，但自己还没完全准备好时，就先放在这里。\n\n3.  **singletonFactories (三级缓存)**：\n    *   **作用**：存放一个 `ObjectFactory`（对象工厂）。\n    *   **Bean 的状态**：连实例化都还没完成，只是一个创建 Bean 的工厂。\n    *   **目的**：这是最核心、最巧妙的一层。它存储的不是 Bean 对象本身，而是一个能够创建 Bean 对象的工厂（通常是一个 lambda 表达式）。这个工厂在被调用时，会创建 Bean 的实例，并可能应用一些 **AOP 代理**。Spring 将这个工厂暴露出去，当其他 Bean 需要这个“早期”Bean 时，会通过这个工厂获取。\n\n#### 解决循环依赖的流程（以 A 和 B 为例）\n\n假设 A 和 B 相互依赖，通过 `@Autowired` 注入。\n\n1.  **创建 Bean A**\n    *   `getBean(\"a\")` -> 调用 `doGetBean()`。\n    *   Spring 尝试从三级缓存中获取 A，没有。\n    *   **实例化 A**：通过反射调用构造函数，创建一个 A 的原始实例 `new A()`。\n    *   在 A 的实例化之后、属性填充之前，Spring **将 A 的“早期引用”放入三级缓存**。具体是创建一个 `ObjectFactory`，这个工厂知道如何获取 A 的实例（此时就是 `new A()` 那个对象）。\n        *   `singletonFactories.put(\"a\", () -> getEarlyBeanReference(\"a\", ...))`。\n    *   然后开始 **填充 A 的属性**。Spring 发现 A 需要 B，于是调用 `getBean(\"b\")` 去创建 B。\n\n2.  **创建 Bean B**\n    *   `getBean(\"b\")` -> 调用 `doGetBean()`。\n    *   Spring 尝试从三级缓存中获取 B，没有。\n    *   **实例化 B**：`new B()`。\n    *   **将 B 的“早期引用”放入三级缓存**。\n        *   `singletonFactories.put(\"b\", () -> getEarlyBeanReference(\"b\", ...))`。\n    *   开始 **填充 B 的属性**。Spring 发现 B 需要 A，于是调用 `getBean(\"a\")` 去创建 A。\n\n3.  **解决 A 的依赖**\n    *   `getBean(\"a\")` 再次被调用。\n    *   这次，Spring 尝试从三级缓存中获取 A。\n    *   **找到了！** `singletonFactories.get(\"a\")` 返回了那个 `ObjectFactory`。\n    *   Spring 调用这个 `ObjectFactory.getObject()` 方法，得到 A 的早期实例。\n    *   这个早期实例被 **从三级缓存移除**，并 **放入二级缓存**。\n        *   `earlySingletonObjects.put(\"a\", a_early_instance)`。\n    *   `getBean(\"a\")` 立即返回这个 `a_early_instance`。\n\n4.  **完成 B 的创建**\n    *   现在，B 的属性填充得到了 A 的早期实例。\n    *   B 的属性填充完成。\n    *   B 进行初始化。\n    *   B 初始化完成后，被放入 **一级缓存**。\n        *   `singletonObjects.put(\"b\", b_full_instance)`。\n    *   同时，B 的早期引用从二级和三级缓存中移除。\n\n5.  **完成 A 的创建**\n    *   回到步骤 1 中填充 A 的属性的环节。\n    *   A 已经成功获取到了完全初始化好的 B 实例。\n    *   A 的属性填充完成。\n    *   A 进行初始化。\n    *   A 初始化完成后，被放入 **一级缓存**。\n        *   `singletonObjects.put(\"a\", a_full_instance)`。\n    *   同时，A 的早期引用从二级和三级缓存中移除。\n\n至此，A 和 B 都成功创建，并且相互引用正确。\n\n### 3. 为什么需要三级缓存？二级不行吗？\n\n这是一个非常经典的问题。关键在于 **AOP 代理**。\n\n*   **一级缓存 (singletonObjects)**：存放最终的、成熟的 Bean。如果 Bean 需要被代理（例如通过 `@Transactional`），那么在这里存放的就是代理对象。\n*   **二级缓存 (earlySingletonObjects)**：存放早期暴露的 Bean 实例。如果只有二级缓存，那么暴露出去的就是原始对象。\n*   **三级缓存 (singletonFactories)**：存放一个 `ObjectFactory`。\n\n**场景**：Bean A 和 Bean B 循环依赖，且 A 需要被 AOP 代理。\n\n1.  如果只有二级缓存：\n    *   创建 A 的原始实例。\n    *   将 A 的原始实例放入二级缓存。\n    *   填充 A 的属性，需要 B。\n    *   创建 B，填充 B 的属性，需要 A。从二级缓存拿到 A 的 **原始实例**。\n    *   B 创建完成。\n    *   A 填充完成，开始初始化，然后进行 AOP 代理，生成代理对象 `A_proxy`。\n    *   最终容器中 A 的实例是 `A_proxy`，但 B 中持有的是 A 的 **原始实例**。**这会导致 B 中对 A 的调用不会经过代理，AOP 失效！**\n\n2.  有了三级缓存：\n    *   创建 A 的原始实例。\n    *   将一个 `ObjectFactory` 放入三级缓存。这个工厂的逻辑是：“如果有人现在就要 A 的早期引用，我就先对 A 的原始实例进行 AOP 代理，然后返回代理对象。”\n    *   填充 A 的属性，需要 B。\n    *   创建 B，填充 B 的属性，需要 A。\n    *   从三级缓存拿到 A 的 `ObjectFactory`，并调用 `getObject()`。\n        *   此时，`getEarlyBeanReference()` 方法被调用，它会检查 A 是否需要代理。如果需要，就在这里创建 A 的代理对象 `A_proxy`。\n    *   `A_proxy` 被放入二级缓存，并返回给 B 进行注入。\n    *   B 持有的是 `A_proxy`。\n    *   后续 A 初始化完成，放入一级缓存的也是 `A_proxy`。\n    *   这样，B 中对 A 的调用就能正常走代理了。\n\n**总结**：三级缓存的真正价值在于，它提供了一个 **切入点**，让我们可以在 Bean 的早期阶段就完成代理逻辑，从而保证即使在循环依赖的情况下，AOP 也能正常工作。\n\n### 4. 无法解决的循环依赖\n\nSpring 的三级缓存机制并不能解决所有类型的循环依赖。它主要对 **Setter/Field 注入** 有效。\n\n*   **构造器注入 (Constructor Injection)**：\n    *   Spring **无法解决** 构造器注入的循环依赖。\n    *   **原因**：在调用构造函数 `new A(b)` 时，必须先提供 B 的实例。而创建 B 又需要 A 的实例。此时 Bean 还未实例化，没有“半成品”可以暴露，因此会直接抛出 `BeanCurrentlyInCreationException` 异常。\n    *   **最佳实践**：尽量使用构造器注入，它能让你在启动时就发现循环依赖的问题，而不是在运行时才暴露。\n\n*   **Prototype (原型) 作用域**：\n    *   Spring **无法解决** Prototype 作用域的循环依赖。\n    *   **原因**：Spring 不会缓存 Prototype Bean。每次请求 Prototype Bean 时，都会创建一个新实例。对于循环依赖，它会陷入无限递归创建新实例的死循环，最终导致 `StackOverflowError`。\n\n### 总结\n\n| 特性 | 描述 |\n| :--- | :--- |\n| **核心机制** | **三级缓存** + **提前暴露** |\n| **解决场景** | **Setter/Field 注入** 的单例 Bean 循环依赖。 |\n| **无法解决** | **构造器注入**、**Prototype 作用域** 的循环依赖。 |\n| **三级缓存作用** | 1. `singletonObjects`: 存放最终的成熟Bean。<br>2. `earlySingletonObjects`: 存放早期的Bean实例（已实例化，未初始化）。<br>3. `singletonFactories`: 存放创建Bean的工厂，用于处理AOP代理。 |\n| **设计建议** | 尽量避免循环依赖，优先使用构造器注入。如果无法避免，使用 Setter/Field 注入。 |"
} ]